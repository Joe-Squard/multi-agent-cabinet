#!/bin/bash
set -euo pipefail

# db_schema_doc.sh - Generate Markdown documentation from ORM schema files
# Usage: db_schema_doc.sh [project_path]
# Exit codes: 0=OK, 1=no schema found, 2=error

PROJECT_PATH="${1:-$(git rev-parse --show-toplevel 2>/dev/null || echo ".")}"
PROJECT_PATH="$(cd "$PROJECT_PATH" && pwd)"

ORM_DETECTED=""
SCHEMA_FILES=()

echo "# Database Schema Documentation"
echo ""
echo "> Auto-generated by db_schema_doc.sh on $(date '+%Y-%m-%d %H:%M:%S')"
echo ""

# ============================================================
# Detect ORM and find schema files
# ============================================================

# --- Prisma ---
PRISMA_SCHEMA=""
for candidate in \
    "$PROJECT_PATH/prisma/schema.prisma" \
    "$PROJECT_PATH/schema.prisma" \
    "$PROJECT_PATH/src/prisma/schema.prisma"; do
    if [[ -f "$candidate" ]]; then
        PRISMA_SCHEMA="$candidate"
        ORM_DETECTED="Prisma"
        break
    fi
done

# --- SQLAlchemy ---
SQLALCHEMY_FILES=()
if [[ -z "$ORM_DETECTED" ]]; then
    while IFS= read -r -d '' f; do
        if grep -qlE 'from sqlalchemy|from sqlmodel|Column\(|mapped_column|DeclarativeBase|declarative_base' "$f" 2>/dev/null; then
            SQLALCHEMY_FILES+=("$f")
        fi
    done < <(find "$PROJECT_PATH" -type f -name "*.py" ! -path "*/node_modules/*" ! -path "*/.venv/*" ! -path "*/venv/*" ! -path "*/__pycache__/*" -print0 2>/dev/null)

    if [[ ${#SQLALCHEMY_FILES[@]} -gt 0 ]]; then
        ORM_DETECTED="SQLAlchemy"
    fi
fi

# --- TypeORM ---
TYPEORM_FILES=()
if [[ -z "$ORM_DETECTED" ]]; then
    while IFS= read -r -d '' f; do
        TYPEORM_FILES+=("$f")
    done < <(find "$PROJECT_PATH" -type f -name "*.entity.ts" ! -path "*/node_modules/*" ! -path "*/dist/*" -print0 2>/dev/null)

    if [[ ${#TYPEORM_FILES[@]} -gt 0 ]]; then
        ORM_DETECTED="TypeORM"
    fi
fi

# --- Drizzle ---
DRIZZLE_FILES=()
if [[ -z "$ORM_DETECTED" ]]; then
    while IFS= read -r -d '' f; do
        if grep -qlE 'pgTable|mysqlTable|sqliteTable|createTable' "$f" 2>/dev/null; then
            DRIZZLE_FILES+=("$f")
        fi
    done < <(find "$PROJECT_PATH" -type f \( -name "schema.ts" -o -name "schema.js" -o -name "*.schema.ts" \) ! -path "*/node_modules/*" ! -path "*/dist/*" -print0 2>/dev/null)

    if [[ ${#DRIZZLE_FILES[@]} -gt 0 ]]; then
        ORM_DETECTED="Drizzle"
    fi
fi

if [[ -z "$ORM_DETECTED" ]]; then
    echo "No supported ORM schema detected."
    echo ""
    echo "Supported ORMs: Prisma, SQLAlchemy, TypeORM, Drizzle"
    exit 1
fi

echo "**ORM:** $ORM_DETECTED"
echo ""

# ============================================================
# Parse Prisma Schema
# ============================================================

parse_prisma() {
    local schema_file="$1"
    local in_model=false
    local model_name=""

    echo "**Schema file:** \`${schema_file#$PROJECT_PATH/}\`"
    echo ""

    while IFS= read -r line; do
        # Strip leading/trailing whitespace
        local trimmed
        trimmed=$(echo "$line" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

        # Skip empty lines and comments outside models
        [[ -z "$trimmed" ]] && continue
        [[ "$trimmed" =~ ^// ]] && continue

        # Detect model start
        if [[ "$trimmed" =~ ^model[[:space:]]+([A-Za-z_]+)[[:space:]]*\{ ]]; then
            model_name="${BASH_REMATCH[1]}"
            in_model=true
            echo "## $model_name"
            echo ""
            echo "| Column | Type | Constraints |"
            echo "|--------|------|-------------|"
            continue
        fi

        # Detect enum start
        if [[ "$trimmed" =~ ^enum[[:space:]]+([A-Za-z_]+)[[:space:]]*\{ ]]; then
            local enum_name="${BASH_REMATCH[1]}"
            echo "## Enum: $enum_name"
            echo ""
            echo "| Value |"
            echo "|-------|"
            # Read enum values until closing brace
            while IFS= read -r eline; do
                local etrimmed
                etrimmed=$(echo "$eline" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
                [[ "$etrimmed" == "}" ]] && break
                [[ -z "$etrimmed" || "$etrimmed" =~ ^// ]] && continue
                echo "| $etrimmed |"
            done
            echo ""
            continue
        fi

        # Detect model end
        if [[ "$in_model" == true && "$trimmed" == "}" ]]; then
            in_model=false
            echo ""
            continue
        fi

        # Parse model fields
        if [[ "$in_model" == true ]]; then
            # Skip relation-only lines and @@directives
            [[ "$trimmed" =~ ^@@ ]] && continue

            # Parse: fieldName Type? @constraints
            if [[ "$trimmed" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]+([A-Za-z_\[\]?]+)(.*) ]]; then
                local field_name="${BASH_REMATCH[1]}"
                local field_type="${BASH_REMATCH[2]}"
                local rest="${BASH_REMATCH[3]}"

                # Extract constraints
                local constraints=""
                if [[ "$rest" =~ @id ]]; then constraints+="PRIMARY KEY, "; fi
                if [[ "$rest" =~ @unique ]]; then constraints+="UNIQUE, "; fi
                if [[ "$rest" =~ @default ]]; then
                    local default_val
                    default_val=$(echo "$rest" | grep -oE '@default\([^)]+\)' | head -1)
                    constraints+="$default_val, "
                fi
                if [[ "$rest" =~ @relation ]]; then constraints+="RELATION, "; fi
                if [[ "$rest" =~ @updatedAt ]]; then constraints+="AUTO_UPDATE, "; fi
                if [[ "$field_type" == *"?" ]]; then constraints+="NULLABLE, "; fi

                # Remove trailing comma
                constraints=$(echo "$constraints" | sed 's/, $//')

                echo "| $field_name | $field_type | $constraints |"
            fi
        fi
    done < "$schema_file"
}

# ============================================================
# Parse SQLAlchemy Models
# ============================================================

parse_sqlalchemy() {
    echo "**Model files:** ${#SQLALCHEMY_FILES[@]} files"
    echo ""

    for file in "${SQLALCHEMY_FILES[@]}"; do
        local rel_path="${file#$PROJECT_PATH/}"
        local in_class=false
        local class_name=""
        local table_name=""
        local has_columns=false

        while IFS= read -r line; do
            local trimmed
            trimmed=$(echo "$line" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

            # Detect class definition
            if [[ "$trimmed" =~ ^class[[:space:]]+([A-Za-z_]+)\( ]]; then
                if [[ "$has_columns" == true ]]; then
                    echo ""
                fi
                class_name="${BASH_REMATCH[1]}"
                in_class=true
                has_columns=false
                table_name=""
                continue
            fi

            if [[ "$in_class" == true ]]; then
                # Detect __tablename__
                if [[ "$trimmed" =~ __tablename__[[:space:]]*=[[:space:]]*[\"\'](.*?)[\"\'] ]]; then
                    table_name="${BASH_REMATCH[1]}"
                fi

                # Detect Column definitions
                if [[ "$trimmed" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*[:=].*Column\( || "$trimmed" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*[:=].*mapped_column\( ]]; then
                    if [[ "$has_columns" == false ]]; then
                        local display_name="${table_name:-$class_name}"
                        echo "## $display_name"
                        echo ""
                        echo "*File: \`$rel_path\`*"
                        echo ""
                        echo "| Column | Type | Constraints |"
                        echo "|--------|------|-------------|"
                        has_columns=true
                    fi

                    local col_name="${BASH_REMATCH[1]}"
                    local col_type=""
                    local constraints=""

                    # Extract type
                    col_type=$(echo "$trimmed" | grep -oE '(String|Integer|Float|Boolean|DateTime|Text|BigInteger|SmallInteger|JSON|UUID|Numeric|Date|Time|LargeBinary|Enum)(\([^)]*\))?' | head -1 || echo "")

                    # Extract constraints
                    if echo "$trimmed" | grep -q "primary_key\s*=\s*True"; then constraints+="PRIMARY KEY, "; fi
                    if echo "$trimmed" | grep -q "unique\s*=\s*True"; then constraints+="UNIQUE, "; fi
                    if echo "$trimmed" | grep -q "nullable\s*=\s*False"; then constraints+="NOT NULL, "; fi
                    if echo "$trimmed" | grep -q "nullable\s*=\s*True"; then constraints+="NULLABLE, "; fi
                    if echo "$trimmed" | grep -q "index\s*=\s*True"; then constraints+="INDEXED, "; fi
                    if echo "$trimmed" | grep -q "ForeignKey"; then
                        local fk
                        fk=$(echo "$trimmed" | grep -oE "ForeignKey\(['\"]([^'\"]+)['\"]\)" | head -1 || echo "FK")
                        constraints+="$fk, "
                    fi
                    if echo "$trimmed" | grep -q "default"; then constraints+="HAS DEFAULT, "; fi

                    constraints=$(echo "$constraints" | sed 's/, $//')

                    echo "| $col_name | ${col_type:-?} | $constraints |"
                fi

                # Detect relationship (informational)
                if [[ "$trimmed" =~ ^([a-zA-Z_]+)[[:space:]]*[:=].*relationship\( ]]; then
                    if [[ "$has_columns" == true ]]; then
                        local rel_name="${BASH_REMATCH[1]}"
                        echo "| *$rel_name* | *relationship* | |"
                    fi
                fi
            fi
        done < "$file"

        if [[ "$has_columns" == true ]]; then
            echo ""
        fi
    done
}

# ============================================================
# Parse TypeORM Entities
# ============================================================

parse_typeorm() {
    echo "**Entity files:** ${#TYPEORM_FILES[@]} files"
    echo ""

    for file in "${TYPEORM_FILES[@]}"; do
        local rel_path="${file#$PROJECT_PATH/}"
        local in_entity=false
        local entity_name=""
        local has_columns=false
        local pending_decorators=""

        while IFS= read -r line; do
            local trimmed
            trimmed=$(echo "$line" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

            # Detect @Entity()
            if [[ "$trimmed" =~ @Entity ]]; then
                in_entity=true
                continue
            fi

            # Detect class name after @Entity
            if [[ "$in_entity" == true && "$trimmed" =~ ^(export[[:space:]]+)?class[[:space:]]+([A-Za-z_]+) ]]; then
                entity_name="${BASH_REMATCH[2]}"
                echo "## $entity_name"
                echo ""
                echo "*File: \`$rel_path\`*"
                echo ""
                echo "| Column | Type | Constraints |"
                echo "|--------|------|-------------|"
                has_columns=true
                continue
            fi

            if [[ "$has_columns" == true ]]; then
                # Collect decorators
                if [[ "$trimmed" =~ ^@(PrimaryGeneratedColumn|PrimaryColumn|Column|CreateDateColumn|UpdateDateColumn|DeleteDateColumn|ManyToOne|OneToMany|ManyToMany|OneToOne|JoinColumn) ]]; then
                    pending_decorators+=" $trimmed"
                    continue
                fi

                # Field declaration
                if [[ -n "$pending_decorators" && "$trimmed" =~ ^([a-zA-Z_][a-zA-Z0-9_?]*)[[:space:]]*:?[[:space:]]*([a-zA-Z_\[\]|]+)? ]]; then
                    local field_name="${BASH_REMATCH[1]}"
                    local field_ts_type="${BASH_REMATCH[2]:-?}"
                    local constraints=""

                    if echo "$pending_decorators" | grep -q "@PrimaryGeneratedColumn"; then constraints+="PRIMARY KEY, AUTO, "; fi
                    if echo "$pending_decorators" | grep -q "@PrimaryColumn"; then constraints+="PRIMARY KEY, "; fi
                    if echo "$pending_decorators" | grep -q "@CreateDateColumn"; then constraints+="AUTO_CREATE, "; fi
                    if echo "$pending_decorators" | grep -q "@UpdateDateColumn"; then constraints+="AUTO_UPDATE, "; fi
                    if echo "$pending_decorators" | grep -q "@DeleteDateColumn"; then constraints+="SOFT_DELETE, "; fi
                    if echo "$pending_decorators" | grep -q "unique: true"; then constraints+="UNIQUE, "; fi
                    if echo "$pending_decorators" | grep -q "nullable: true"; then constraints+="NULLABLE, "; fi
                    if echo "$pending_decorators" | grep -q "@ManyToOne\|@OneToMany\|@ManyToMany\|@OneToOne"; then constraints+="RELATION, "; fi

                    # Extract Column type if specified
                    local col_type
                    col_type=$(echo "$pending_decorators" | grep -oE "type:\s*['\"]([^'\"]+)['\"]" | sed "s/type:\s*['\"]//;s/['\"]$//" || echo "")

                    local display_type="${col_type:-$field_ts_type}"

                    constraints=$(echo "$constraints" | sed 's/, $//')
                    field_name=$(echo "$field_name" | sed 's/[?!]$//')

                    echo "| $field_name | $display_type | $constraints |"
                    pending_decorators=""
                fi

                # End of class
                if [[ "$trimmed" == "}" && -z "$pending_decorators" ]]; then
                    has_columns=false
                    in_entity=false
                    echo ""
                fi
            fi
        done < "$file"

        if [[ "$has_columns" == true ]]; then
            echo ""
        fi
    done
}

# ============================================================
# Parse Drizzle Schema
# ============================================================

parse_drizzle() {
    echo "**Schema files:** ${#DRIZZLE_FILES[@]} files"
    echo ""

    for file in "${DRIZZLE_FILES[@]}"; do
        local rel_path="${file#$PROJECT_PATH/}"

        # Find table definitions
        while IFS= read -r line; do
            local trimmed
            trimmed=$(echo "$line" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

            # Match: export const tableName = pgTable('table_name', {
            local table_re='(pgTable|mysqlTable|sqliteTable)\([[:space:]]*["'"'"']([^"'"'"']+)["'"'"']'
            if [[ "$trimmed" =~ $table_re ]]; then
                local table_name="${BASH_REMATCH[2]}"
                echo "## $table_name"
                echo ""
                echo "*File: \`$rel_path\`*"
                echo ""
                echo "| Column | Type | Constraints |"
                echo "|--------|------|-------------|"
            fi

            # Match column definitions: fieldName: type('column_name').constraints
            local col_re='^([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*:[[:space:]]*(integer|text|varchar|boolean|timestamp|serial|bigint|real|numeric|uuid|json|jsonb|date|time|bigserial|smallint|char)(.*)$'
            if [[ "$trimmed" =~ $col_re ]]; then
                local col_name="${BASH_REMATCH[1]}"
                local col_type="${BASH_REMATCH[2]}"
                local rest_full="${BASH_REMATCH[3]}"
                local type_args=""
                # Extract type args like ('column_name') if present
                local args_re='^\(([^)]*)\)(.*)'
                if [[ "$rest_full" =~ $args_re ]]; then
                    type_args="(${BASH_REMATCH[1]})"
                    rest_full="${BASH_REMATCH[2]}"
                fi
                local rest="$rest_full"
                local constraints=""

                if echo "$rest" | grep -q "\.primaryKey()"; then constraints+="PRIMARY KEY, "; fi
                if echo "$rest" | grep -q "\.notNull()"; then constraints+="NOT NULL, "; fi
                if echo "$rest" | grep -q "\.unique()"; then constraints+="UNIQUE, "; fi
                if echo "$rest" | grep -q "\.default("; then constraints+="HAS DEFAULT, "; fi
                if echo "$rest" | grep -q "\.references("; then constraints+="FOREIGN KEY, "; fi

                constraints=$(echo "$constraints" | sed 's/, $//')

                # Extract column name from type args if present
                local db_name=""
                if [[ -n "$type_args" ]]; then
                    db_name=$(echo "$type_args" | grep -oE "['\"]([^'\"]+)['\"]" | tr -d "'" | tr -d '"' | head -1)
                fi

                local display_name="${db_name:-$col_name}"
                echo "| $display_name | ${col_type}${type_args} | $constraints |"
            fi
        done < "$file"

        echo ""
    done
}

# ============================================================
# Dispatch
# ============================================================

case "$ORM_DETECTED" in
    Prisma)      parse_prisma "$PRISMA_SCHEMA" ;;
    SQLAlchemy)  parse_sqlalchemy ;;
    TypeORM)     parse_typeorm ;;
    Drizzle)     parse_drizzle ;;
esac

echo "---"
echo ""
echo "*Generated from \`${PROJECT_PATH}\` using \`$ORM_DETECTED\`*"

exit 0
